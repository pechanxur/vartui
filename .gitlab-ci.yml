workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "web"'

stages:
  - test
  - version
  - build
  - release
  - homebrew

variables:
  GIT_DEPTH: "0"
  CARGO_TERM_COLOR: always

test:
  stage: test
  image: rust:1.86-bookworm
  tags:
    - linux-x86_64
  script:
    - cargo test --locked --all-targets

version:
  stage: version
  image: rust:1.86-bookworm
  tags:
    - linux-x86_64
  needs:
    - job: test
  script:
    - git fetch --force --tags
    - |
      python3 - <<'PY'
      import os
      import re
      import subprocess

      project_url = os.environ["CI_PROJECT_URL"]

      def git(*args):
          return subprocess.check_output(["git", *args], text=True).strip()

      tags_raw = git("tag", "--list", "v*", "--sort=-version:refname")
      tags = [tag for tag in tags_raw.splitlines() if re.fullmatch(r"v\d+\.\d+\.\d+", tag)]
      previous_tag = tags[0] if tags else ""

      base_major, base_minor, base_patch = 0, 0, 0
      rev_range = "HEAD"
      if previous_tag:
          base_major, base_minor, base_patch = map(int, previous_tag[1:].split("."))
          rev_range = f"{previous_tag}..HEAD"

      raw = subprocess.check_output(
          [
              "git",
              "log",
              rev_range,
              "--no-merges",
              "--format=%H%x1f%s%x1f%b%x1e",
          ],
          text=True,
      ).strip("\n\x1e")

      records = [chunk for chunk in raw.split("\x1e") if chunk.strip()]

      major_pattern = re.compile(r"^[A-Za-z]+(\([^)]+\))?!:\s*(.+)$")
      feat_pattern = re.compile(r"^feat(\([^)]+\))?:\s*(.+)$")
      fix_pattern = re.compile(r"^fix(\([^)]+\))?:\s*(.+)$")

      def normalized_subject(subject: str) -> str:
          for pattern in (major_pattern, feat_pattern, fix_pattern):
              match = pattern.match(subject)
              if match:
                  return match.group(2).strip()
          return subject.strip()

      def release_line(sha: str, subject: str) -> str:
          message = normalized_subject(subject)
          return f"- {message} ([`{sha[:7]}`]({project_url}/-/commit/{sha}))"

      bump = None
      breaking = []
      features = []
      fixes = []

      for record in records:
          parts = record.split("\x1f")
          if len(parts) < 3:
              continue

          sha = parts[0].strip()
          subject = parts[1].strip()
          body = parts[2]
          is_breaking = "BREAKING CHANGE" in body or bool(major_pattern.match(subject))

          if is_breaking:
              breaking.append(release_line(sha, subject))
              bump = "major"
              continue

          if feat_pattern.match(subject):
              features.append(release_line(sha, subject))
              if bump != "major":
                  bump = "minor"
              continue

          if fix_pattern.match(subject):
              fixes.append(release_line(sha, subject))
              if bump is None:
                  bump = "patch"

      release_enabled = bump is not None
      if not release_enabled:
          version = previous_tag[1:] if previous_tag else "0.0.0"
          tag = previous_tag
      else:
          next_major, next_minor, next_patch = base_major, base_minor, base_patch
          if bump == "major":
              next_major += 1
              next_minor = 0
              next_patch = 0
          elif bump == "minor":
              next_minor += 1
              next_patch = 0
          else:
              next_patch += 1

          version = f"{next_major}.{next_minor}.{next_patch}"
          tag = f"v{version}"

      notes = []
      if release_enabled:
          notes.extend(
              [
                  f"Automated {bump} release for vartui.",
                  "",
                  f"- Version: {version}",
                  f"- Tag: {tag}",
              ]
          )

          if previous_tag and previous_tag != tag:
              notes.append(f"- Compare: {project_url}/-/compare/{previous_tag}...{tag}")

          notes.extend(["", "## Changelog"])
          if breaking:
              notes.extend(["", "### Breaking Changes", *breaking])
          if features:
              notes.extend(["", "### Features", *features])
          if fixes:
              notes.extend(["", "### Fixes", *fixes])

      with open("release-notes.md", "w", encoding="utf-8") as notes_file:
          if notes:
              notes_file.write("\n".join(notes).rstrip() + "\n")
          else:
              notes_file.write("No release generated in this pipeline.\n")

      with open("release.env", "w", encoding="utf-8") as env_file:
          env_file.write(f"RELEASE_ENABLED={'true' if release_enabled else 'false'}\n")
          env_file.write(f"RELEASE_BUMP={bump or 'none'}\n")
          env_file.write(f"RELEASE_VERSION={version}\n")
          env_file.write(f"RELEASE_TAG={tag}\n")
          env_file.write(f"PREVIOUS_TAG={previous_tag}\n")
      PY
  artifacts:
    reports:
      dotenv: release.env
    paths:
      - release.env
      - release-notes.md
    expire_in: 1 week

build_linux_x86_64:
  stage: build
  image: rust:1.86-bookworm
  tags:
    - linux-x86_64
  needs:
    - job: version
      artifacts: true
  script:
    - . ./release.env
    - if [ "${RELEASE_ENABLED}" != "true" ]; then echo "No release; skipping build."; exit 0; fi
    - rustup target add x86_64-unknown-linux-gnu
    - cargo build --release --locked --target x86_64-unknown-linux-gnu
    - mkdir -p release-assets
    - asset="vartui-${RELEASE_TAG}-linux-x86_64"
    - cp target/x86_64-unknown-linux-gnu/release/vartui release-assets/vartui
    - chmod +x release-assets/vartui
    - tar -C release-assets -czf "release-assets/${asset}.tar.gz" vartui
    - shasum -a 256 "release-assets/${asset}.tar.gz" | awk '{print $1}' > "release-assets/${asset}.sha256"
    - rm -f release-assets/vartui
  artifacts:
    paths:
      - release-assets/*
    expire_in: 1 week

build_linux_arm64:
  stage: build
  image: rust:1.86-bookworm
  tags:
    - linux-arm64
  needs:
    - job: version
      artifacts: true
  script:
    - . ./release.env
    - if [ "${RELEASE_ENABLED}" != "true" ]; then echo "No release; skipping build."; exit 0; fi
    - rustup target add aarch64-unknown-linux-gnu
    - cargo build --release --locked --target aarch64-unknown-linux-gnu
    - mkdir -p release-assets
    - asset="vartui-${RELEASE_TAG}-linux-arm64"
    - cp target/aarch64-unknown-linux-gnu/release/vartui release-assets/vartui
    - chmod +x release-assets/vartui
    - tar -C release-assets -czf "release-assets/${asset}.tar.gz" vartui
    - shasum -a 256 "release-assets/${asset}.tar.gz" | awk '{print $1}' > "release-assets/${asset}.sha256"
    - rm -f release-assets/vartui
  artifacts:
    paths:
      - release-assets/*
    expire_in: 1 week

build_macos_x86_64:
  stage: build
  tags:
    - macos-x86_64
  needs:
    - job: version
      artifacts: true
  script:
    - . ./release.env
    - if [ "${RELEASE_ENABLED}" != "true" ]; then echo "No release; skipping build."; exit 0; fi
    - if ! command -v rustup >/dev/null 2>&1; then curl https://sh.rustup.rs -sSf | sh -s -- -y --profile minimal; fi
    - . "$HOME/.cargo/env"
    - rustup toolchain install stable --profile minimal
    - rustup default stable
    - rustup target add x86_64-apple-darwin
    - cargo build --release --locked --target x86_64-apple-darwin
    - mkdir -p release-assets
    - asset="vartui-${RELEASE_TAG}-darwin-x86_64"
    - cp target/x86_64-apple-darwin/release/vartui release-assets/vartui
    - chmod +x release-assets/vartui
    - tar -C release-assets -czf "release-assets/${asset}.tar.gz" vartui
    - shasum -a 256 "release-assets/${asset}.tar.gz" | awk '{print $1}' > "release-assets/${asset}.sha256"
    - rm -f release-assets/vartui
  artifacts:
    paths:
      - release-assets/*
    expire_in: 1 week

build_macos_arm64:
  stage: build
  tags:
    - macos-arm64
  needs:
    - job: version
      artifacts: true
  script:
    - . ./release.env
    - if [ "${RELEASE_ENABLED}" != "true" ]; then echo "No release; skipping build."; exit 0; fi
    - if ! command -v rustup >/dev/null 2>&1; then curl https://sh.rustup.rs -sSf | sh -s -- -y --profile minimal; fi
    - . "$HOME/.cargo/env"
    - rustup toolchain install stable --profile minimal
    - rustup default stable
    - rustup target add aarch64-apple-darwin
    - cargo build --release --locked --target aarch64-apple-darwin
    - mkdir -p release-assets
    - asset="vartui-${RELEASE_TAG}-darwin-arm64"
    - cp target/aarch64-apple-darwin/release/vartui release-assets/vartui
    - chmod +x release-assets/vartui
    - tar -C release-assets -czf "release-assets/${asset}.tar.gz" vartui
    - shasum -a 256 "release-assets/${asset}.tar.gz" | awk '{print $1}' > "release-assets/${asset}.sha256"
    - rm -f release-assets/vartui
  artifacts:
    paths:
      - release-assets/*
    expire_in: 1 week

build_windows_x86_64:
  stage: build
  tags:
    - windows-x86_64
  needs:
    - job: version
      artifacts: true
  script:
    - |
      Get-Content release.env | ForEach-Object {
        if ($_ -match '^(.*?)=(.*)$') {
          Set-Item -Path "env:$($matches[1])" -Value $matches[2]
        }
      }
      if ($env:RELEASE_ENABLED -ne "true") {
        Write-Host "No release; skipping build."
        exit 0
      }
      if (-not (Get-Command rustup -ErrorAction SilentlyContinue)) {
        Invoke-WebRequest -Uri https://win.rustup.rs -OutFile rustup-init.exe
        Start-Process -FilePath .\rustup-init.exe -ArgumentList "-y" -Wait
        $env:Path = "$env:USERPROFILE\\.cargo\\bin;$env:Path"
      }
      rustup toolchain install stable
      rustup default stable
      rustup target add x86_64-pc-windows-msvc
      cargo build --release --locked --target x86_64-pc-windows-msvc

      New-Item -ItemType Directory -Path release-assets -Force | Out-Null
      $asset = "vartui-$env:RELEASE_TAG-windows-x86_64"
      Copy-Item "target/x86_64-pc-windows-msvc/release/vartui.exe" "release-assets/vartui.exe"
      Compress-Archive -Path "release-assets/vartui.exe" -DestinationPath "release-assets/$asset.zip" -Force
      $hash = (Get-FileHash -Algorithm SHA256 "release-assets/$asset.zip").Hash.ToLower()
      Set-Content -Path "release-assets/$asset.sha256" -Value $hash -NoNewline
      Remove-Item "release-assets/vartui.exe" -Force
  artifacts:
    paths:
      - release-assets/*
    expire_in: 1 week

build_windows_arm64:
  stage: build
  tags:
    - windows-arm64
  needs:
    - job: version
      artifacts: true
  script:
    - |
      Get-Content release.env | ForEach-Object {
        if ($_ -match '^(.*?)=(.*)$') {
          Set-Item -Path "env:$($matches[1])" -Value $matches[2]
        }
      }
      if ($env:RELEASE_ENABLED -ne "true") {
        Write-Host "No release; skipping build."
        exit 0
      }
      if (-not (Get-Command rustup -ErrorAction SilentlyContinue)) {
        Invoke-WebRequest -Uri https://win.rustup.rs -OutFile rustup-init.exe
        Start-Process -FilePath .\rustup-init.exe -ArgumentList "-y" -Wait
        $env:Path = "$env:USERPROFILE\\.cargo\\bin;$env:Path"
      }
      rustup toolchain install stable
      rustup default stable
      rustup target add aarch64-pc-windows-msvc
      cargo build --release --locked --target aarch64-pc-windows-msvc

      New-Item -ItemType Directory -Path release-assets -Force | Out-Null
      $asset = "vartui-$env:RELEASE_TAG-windows-arm64"
      Copy-Item "target/aarch64-pc-windows-msvc/release/vartui.exe" "release-assets/vartui.exe"
      Compress-Archive -Path "release-assets/vartui.exe" -DestinationPath "release-assets/$asset.zip" -Force
      $hash = (Get-FileHash -Algorithm SHA256 "release-assets/$asset.zip").Hash.ToLower()
      Set-Content -Path "release-assets/$asset.sha256" -Value $hash -NoNewline
      Remove-Item "release-assets/vartui.exe" -Force
  artifacts:
    paths:
      - release-assets/*
    expire_in: 1 week

release:
  stage: release
  image: python:3.12-bookworm
  tags:
    - linux-x86_64
  needs:
    - job: version
      artifacts: true
    - job: build_linux_x86_64
      artifacts: true
    - job: build_linux_arm64
      artifacts: true
    - job: build_macos_x86_64
      artifacts: true
    - job: build_macos_arm64
      artifacts: true
    - job: build_windows_x86_64
      artifacts: true
    - job: build_windows_arm64
      artifacts: true
  script:
    - . ./release.env
    - if [ "${RELEASE_ENABLED}" != "true" ]; then echo "No release generated for this pipeline."; exit 0; fi
    - if [ -z "${GITLAB_RELEASE_TOKEN:-}" ]; then echo "Missing GITLAB_RELEASE_TOKEN"; exit 1; fi
    - |
      python3 - <<'PY'
      import json
      import os
      import pathlib
      import urllib.error
      import urllib.parse
      import urllib.request

      api = os.environ["CI_API_V4_URL"]
      project_id = os.environ["CI_PROJECT_ID"]
      project_url = os.environ["CI_PROJECT_URL"]
      commit_sha = os.environ["CI_COMMIT_SHA"]
      tag = os.environ["RELEASE_TAG"]
      token = os.environ["GITLAB_RELEASE_TOKEN"]

      notes = pathlib.Path("release-notes.md").read_text(encoding="utf-8")
      assets_dir = pathlib.Path("release-assets")
      files = sorted([item for item in assets_dir.glob("*") if item.is_file()])
      if not files:
          raise SystemExit("No release assets found.")

      def request(method, url, data=None, content_type=None, expected=(200, 201, 204)):
          headers = {"PRIVATE-TOKEN": token}
          if content_type:
              headers["Content-Type"] = content_type

          req = urllib.request.Request(url, data=data, headers=headers, method=method)
          try:
              with urllib.request.urlopen(req) as response:
                  body = response.read().decode("utf-8", errors="replace")
                  status = response.getcode()
          except urllib.error.HTTPError as error:
              body = error.read().decode("utf-8", errors="replace")
              status = error.code

          if status not in expected:
              raise RuntimeError(f"Request failed [{status}] {url}\n{body}")
          return status, body

      tag_url = f"{api}/projects/{project_id}/repository/tags/{urllib.parse.quote(tag, safe='')}"
      status, _ = request("GET", tag_url, expected=(200, 404))
      if status == 404:
          payload = urllib.parse.urlencode({"tag_name": tag, "ref": commit_sha}).encode("utf-8")
          request(
              "POST",
              f"{api}/projects/{project_id}/repository/tags",
              data=payload,
              content_type="application/x-www-form-urlencoded",
              expected=(201,),
          )

      links = []
      for file_path in files:
          upload_url = (
              f"{api}/projects/{project_id}/packages/generic/vartui/{tag}/"
              f"{urllib.parse.quote(file_path.name)}"
          )
          request(
              "PUT",
              upload_url,
              data=file_path.read_bytes(),
              content_type="application/octet-stream",
              expected=(201,),
          )
          links.append(
              {
                  "name": file_path.name,
                  "url": f"{project_url}/-/packages/generic/vartui/{tag}/{file_path.name}",
              }
          )

      release_url = f"{api}/projects/{project_id}/releases/{urllib.parse.quote(tag, safe='')}"
      status, _ = request("GET", release_url, expected=(200, 404))
      if status == 200:
          request("DELETE", release_url, expected=(204,))

      payload = {
          "name": tag,
          "tag_name": tag,
          "description": notes,
          "assets": {"links": links},
      }
      request(
          "POST",
          f"{api}/projects/{project_id}/releases",
          data=json.dumps(payload).encode("utf-8"),
          content_type="application/json",
          expected=(201,),
      )
      PY

homebrew:
  stage: homebrew
  image: rust:1.86-bookworm
  tags:
    - linux-x86_64
  needs:
    - job: version
      artifacts: true
    - job: release
      artifacts: false
  script:
    - . ./release.env
    - if [ "${RELEASE_ENABLED}" != "true" ]; then echo "No release; skipping Homebrew update."; exit 0; fi
    - if [ -z "${HOMEBREW_TAP_REPO:-}" ] || [ -z "${HOMEBREW_TAP_TOKEN:-}" ]; then echo "Missing HOMEBREW_TAP_REPO or HOMEBREW_TAP_TOKEN; skipping Homebrew update."; exit 0; fi
    - if [ -z "${GITLAB_RELEASE_TOKEN:-}" ]; then echo "Missing GITLAB_RELEASE_TOKEN"; exit 1; fi
    - mkdir -p release-assets
    - |
      for file in "vartui-${RELEASE_TAG}-darwin-arm64.sha256" "vartui-${RELEASE_TAG}-darwin-x86_64.sha256"; do
        curl --fail --location \
          --header "PRIVATE-TOKEN: ${GITLAB_RELEASE_TOKEN}" \
          --output "release-assets/${file}" \
          "${CI_PROJECT_URL}/-/packages/generic/vartui/${RELEASE_TAG}/${file}"
      done
    - sha_arm64="$(tr -d '\n\r ' < "release-assets/vartui-${RELEASE_TAG}-darwin-arm64.sha256")"
    - sha_x86_64="$(tr -d '\n\r ' < "release-assets/vartui-${RELEASE_TAG}-darwin-x86_64.sha256")"
    - git clone "https://oauth2:${HOMEBREW_TAP_TOKEN}@${CI_SERVER_HOST}/${HOMEBREW_TAP_REPO}.git" tap-repo
    - |
      ./scripts/homebrew/generate-formula.sh \
        --project-path "${CI_PROJECT_PATH}" \
        --gitlab-host "${CI_SERVER_HOST}" \
        --tag "${RELEASE_TAG}" \
        --sha-arm64 "${sha_arm64}" \
        --sha-x86_64 "${sha_x86_64}" \
        --output "tap-repo/Formula/vartui.rb"
    - cd tap-repo
    - if git diff --quiet -- Formula/vartui.rb; then echo "No formula changes"; exit 0; fi
    - git add Formula/vartui.rb
    - |
      git -c user.name="gitlab-ci" \
        -c user.email="gitlab-ci@${CI_SERVER_HOST}" \
        commit -m "chore(homebrew): update formula for ${RELEASE_TAG}"
    - git push origin HEAD
